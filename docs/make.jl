using Documenter
using Literate
using WannierIO
using Wannier
using WannierPlots

# I put each tutorial inside the corresponding subdir in `tutorials/`,
# and let Literate.jl generates markdown from them.
# Then Documenter.jl processes the markdown and renders HTML.

# I will copy input files to the Documenter.jl build folder, so I disable
# the auto clean feature of Documenter.jl.
# However, I still want a clean build every time, so I manually clean the build folder.
const BUILD_DIR = joinpath(@__DIR__, "build")
isdir(BUILD_DIR) && rm(BUILD_DIR; recursive=true, force=true)


# the folder where the Literate.jl tutorial scripts are stored
const TUTORIALS_SRCDIR = joinpath(@__DIR__, "../tutorials")
# the folder where the Documenter.jl md (generated by Literate.jl) are stored
const TUTORIALS_OUTDIR = joinpath(@__DIR__, "src/tutorials")
# the folder for saving HTML plots, also the folder for the final HTML pages
const TUTORIALS_BUILDDIR = joinpath(@__DIR__, "build/tutorials")


# Copied from
# https://github.com/thchr/Brillouin.jl/blob/fad88c5b6965fe4bd59e725ea60655348d36ce0f/docs/make.jl#L4
# ---------------------------------------------------------------------------------------- #
# make PlotlyJS plots showable in ```@example ``` blocks, following the approach suggested
# in https://github.com/fredrikekre/Literate.jl/issues/126
using PlotlyJS
struct HTMLPlot
    p
    h::Int # desired display height in pixels
end
HTMLPlot(p) = HTMLPlot(p, 400)
const ROOT_DIR = joinpath(@__DIR__, "build")
const PLOT_DIR = joinpath(ROOT_DIR, "plots")
function Base.show(io::IO, ::MIME"text/html", p::HTMLPlot)
    mkpath(PLOT_DIR)
    path = joinpath(PLOT_DIR, string(hash(p) % UInt32, ".html"))
    PlotlyJS.savefig(p.p, path; format="html")
    return print(
        io,
        "<object type=\"text/html\" data=\"/$(relpath(path, ROOT_DIR))\" style=\"width:100%;height:$(p.h)px;\"></object>",
    )
end
# ---------------------------------------------------------------------------------------- #


# process the tutorial foreword
Literate.markdown(joinpath(TUTORIALS_OUTDIR, "foreword.jl"), TUTORIALS_OUTDIR)

for dir in readdir(TUTORIALS_SRCDIR)
    # skip folders starting with underscore
    # Some times I put work-in-progress folders there but do not want them to be
    # processed by Literate.jl and Documenter.jl.
    isdir(joinpath(TUTORIALS_SRCDIR, dir)) && !startswith(dir, "_") || continue

    println("* Processing tutorial: $dir *")

    # quick hack to skip generated folders during development
    # startswith(dir, [Char('0' + i) for i in 1:9]) && continue

    # jl = filter(x -> endswith(x, ".jl"), readdir(joinpath(TUTORIALS_SRCDIR, dir)))
    # I assume the tutorial file is named as `tutorial.jl`
    jl = "tutorial.jl"

    file = joinpath(TUTORIALS_SRCDIR, dir, jl)
    isfile(file) || error("tutorial file not found: $file")

    outdir = joinpath(TUTORIALS_OUTDIR, dir)

    # generate markdown which will be executed by Documenter.jl
    Literate.markdown(file, outdir)

    # the Documenter.jl execution needs input files, so I copy them to
    # the build folder where the markdown will be executed
    for f in readdir(joinpath(TUTORIALS_SRCDIR, dir))
        # skip the tutorial file
        f == jl && continue

        src = joinpath(TUTORIALS_SRCDIR, dir, f)
        dstdir = joinpath(TUTORIALS_BUILDDIR, dir)
        dst = joinpath(dstdir, f)

        mkpath(dstdir)
        cp(src, dst; force=true, follow_symlinks=true)
    end

    # I skip the execution of the notebook, because
    # 1. it increases the build time
    # 2. somehow ipynb does not show the plots correctly, e.g. bands, WFs, etc.
    # 3. random numbers during execution might cause the notebook output to be different
    # 4. I will let the user download an empty notebook, so that at least they will run once :-)
    Literate.notebook(file, outdir; execute=false)

    # generate a cleansed version w/o comments, so that user can run in CLI
    Literate.script(file, outdir)
end


# process the WannierPlots examples
const PLOTS_EXAMPLES_SRCDIR = joinpath(@__DIR__, "src/WannierPlots/examples")

for jl in readdir(PLOTS_EXAMPLES_SRCDIR)
    # only process jl scripts
    isfile(joinpath(PLOTS_EXAMPLES_SRCDIR, jl)) && endswith(jl, ".jl") || continue

    file = joinpath(PLOTS_EXAMPLES_SRCDIR, jl)
    println("* Processing WannierPlots example: $jl *")

    # quick hack to skip generated folders during development
    # startswith(jl, [Char('0' + i) for i in 1:3]) && continue

    # save the markdown just inside the srcdir
    Literate.markdown(file, PLOTS_EXAMPLES_SRCDIR)

    # I skip the execution of the notebook
    Literate.notebook(file, PLOTS_EXAMPLES_SRCDIR; execute=false)
end

# Copy the input files to the build folder, so that Documenter.jl can correctly
# execute the markdown files.
const PLOTS_EXAMPLES_BUILDDIR = joinpath(@__DIR__, "build/WannierPlots/examples")
mkpath(PLOTS_EXAMPLES_BUILDDIR)

for dir in ["3-band", "4-realspace", "8-fermi_surface"]
    src = joinpath(TUTORIALS_SRCDIR, dir)
    dst = joinpath(PLOTS_EXAMPLES_BUILDDIR, dir)
    cp(src, dst; force=true)
end


# generate the HTML pages by Documenter.jl
makedocs(;
    sitename="Wannier.jl",
    authors="Junfeng Qiao and contributors.",
    clean=false,  # do not clean the build folder before building
    modules=[WannierIO, Wannier, WannierPlots],
    pages=[
        "Home" => "index.md",
        "Getting Started" => "start.md",
        # the tutorials are auto-generated by Literate
        # Here you can specify the name of tutorial page shown in the left sidebar,
        # by changing the key of the pair.
        "Tutorial" => [
            "Foreword" => "tutorials/foreword.md",
            "Maximal localization" => "tutorials/1-maxloc/tutorial.md",
            "Disentanglement" => "tutorials/2-disentangle/tutorial.md",
            "Band structure" => "tutorials/3-band/tutorial.md",
            "Real space WF" => "tutorials/4-realspace/tutorial.md",
            "Parallel transport" => "tutorials/5-parallel_transport/tutorial.md",
            "Split valence/conduction" => "tutorials/6-split/tutorial.md",
            "Constrain WF center" => "tutorials/7-constrain_center/tutorial.md",
            "Fermi surface" => "tutorials/8-fermi_surface/tutorial.md",
            "Parallel transport with custom b-vectors" => "tutorials/9-parallel_transport_bvectors/tutorial.md",
        ],
        "Theory" => [
            "Algorithm" => "theory/algorithm.md",
            "Normalization" => "theory/normalization.md",
        ],
        "API" => [
            "Utility" => "api/util.md",
            "Input/Output" => "api/io.md",
            "B vector" => "api/bvector.md",
            "Model" => "api/model.md",
            "Wannierize" => "api/wannierize.md",
            "Interpolation" => "api/interpolation.md",
            "Real space" => "api/realspace.md",
            "Command line" => "api/cli.md",
        ],
        "Additional packages" => [
            "WannierIO" => [
                "Home" => "WannierIO/index.md",
                "API" => [
                    "Convention" => "WannierIO/api/convention.md",
                    "Util" => "WannierIO/api/util.md",
                    "Wannier90" => "WannierIO/api/w90.md",
                    "Volumetric data" => "WannierIO/api/volumetric.md",
                    "QE" => "WannierIO/api/qe.md",
                ],
            ],
            "WannierPlots" => [
                "Home" => "WannierPlots/index.md",
                # the examples are auto-generated by Literate
                "Examples" => [
                    "Band structure" => "WannierPlots/examples/1-band.md",
                    "Real space WFs" => "WannierPlots/examples/2-wf.md",
                    "Fermi surface" => "WannierPlots/examples/3-fermisurf.md",
                ],
                "API" => [
                    "Band" => "WannierPlots/api/band.md",
                    "Real space" => "WannierPlots/api/realspace.md",
                    # "Fermi surface" => "api/fermisurf.md",
                ],
            ]
        ],
    ],
)
