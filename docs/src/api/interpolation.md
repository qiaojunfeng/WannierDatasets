# Interpolation

This page lists `struct` and `function`s for Wannier interpolation.

There are two flavors of interpolation:

- WS: the Wigner-Seitz interpolation
- MDRS: the Minimal-distance replica selection method

MDRS has better interpolation quality[^WAN20], so it should be used in most cases.
Moreover, we implement two versions of MDRS:

- `MDRSv1`: the original version in `Wannier90`[^WAN20].
    This is slower than the WS interpolation.
- `MDRSv2`: a slightly modified version which removes some for loops, same as what is implemented
    in `Wannier Berri`[^WBERRI]. The speed is similar to the WS interpolation.

By default, we use the `MDRSv2` interpolation.

```@meta
CurrentModule = Wannier
```

## Contents

```@contents
Pages = ["interpolation.md"]
Depth = 2
```

## Index

```@index
Pages = ["interpolation.md"]
```

## R vectors

### RVectors

!!! note

    The R vectors are automatically generated by calling either of these two approaches:
    - [`read_w90_interp`](@ref read_w90_interp) to read the `Wannier90` output `seedname.chk.fmt` file,
        and generate an `InterpModel`,
    - [`InterpModel` constructor](@ref InterpModel)
        to generate the `InterpModel` from a Wannierization `Model`.
    So usually the user does not need to call the following functions.

```@docs
RVectors
check_weights
get_Rvectors_ws
RVectorsMDRS
RVectorsMDRS(Rvectors::RVectors, T::Array{Matrix{Int},3}, Nᵀ::Array{Int,3})
get_Rvectors_mdrs
```

### KRVectors

The `KRVectors` contains both kpoint mappings and `RVectors`,
allowing both forward and inverse Fourier transform.

```@docs
KRVectors
KRVectors(
    lattice::Mat3{T},
    kgrid::Vec3{Int},
    kpoints::Matrix{T},
    k_xyz::Vector{Vec3{Int}},
    xyz_k::Array{Int,3},
    Rvectors::Union{RVectors{T},RVectorsMDRS{T}},
) where {T<:Real}
KRVectors(
    lattice::Mat3{T},
    kgrid::Vec3{Int},
    kpoints::Matrix{T},
    Rvectors::Union{RVectors{T},RVectorsMDRS{T}},
) where {T<:Real}
```

## Fourier transforms

Performs Fourier transform between k and R spaces defined by `KRVectors`.

!!! note

    In general, the user only need to call the `fourier(kRvectors, Oᵏ)`
    and `invfourier(kRvectors, Oᴿ, kpoints)` functions directly,
    irrespective of the type of `kRVectors`.
    Other functions are internally used based on the type of `KRVectors`,
    thanks to multiple dispatch.

```@docs
fourier
invfourier
_fourier_mdrs_v1
_fourier_mdrs_v2
mdrs_v1tov2
_invfourier_mdrs_v1
_invfourier_mdrs_v2
```

## InterpModel

To separate the Wannier interpolation from Wannierization, we have another model,
the `InterpModel`, which is solely for the purpose of interpolation,
while [`Model`](@ref Model) works only for Wannierization.

```@docs
InterpModel
```

## Band structure

!!! warning

    Need some care when comparing the band interpolation between `Wannier.jl` and `Wannier90`,
    after running the `Wannier.jl` disentanglement and writing an optimized `amn` file for
    `Wannier90` to interpolate band structure.

    When `Wannier90` read an `amn` file, it will (`Wannier90` v3.1.0)
    1. Lowdin orthogonalize the `amn` matrices, in `disentangle.F90:dis_project`, line 1418
        This should do no harm, since the optimized amn is already semi-unitary,
        a SVD of it should not change the optimized amn (apart from numerical noise)
    2. generate a new `amn` according to the frozen window, in `disentangle.F90:dis_proj_froz`,
        line 1830. This will **DESTROY** the optimized `amn` matrices, if we restart
        `Wannier90` from the optimized `amn` with `dis_num_iter = 0`, the spreads in `wout` file
        is very different from the output of `Wannier.jl`, we must skip this step by commenting
        out **ALL** the `dis_froz_min/max` in the `win` file, then
        use `Wannier90` to interpolate bands, remember also set `num_iter` and `dis_num_ite = 0`.

```@docs
get_Hk
diag_Hk
interpolate
```

## Fermi surface

!!! note

    The `fermi_surface` function will use WS or MDRS interpolation based on the type of `Rvectors`.
    However, `Wannier90` only use WS interpolation when plotting Fermi surface (even if the
    `use_ws_distance` is set as `true` in the `win` file).
    So the `fermi_surface` function will output different result than `Wannier90` if using MDRS.

```@docs
fermi_surface
```

[^WAN20]: Pizzi, G.; Vitale, V.; Arita, R.; Blügel, S.; Freimuth, F.; Géranton, G.; Gibertini, M.;
    Gresch, D.; Johnson, C.; Koretsune, T.; Ibañez-Azpiroz, J.; Lee, H.; Lihm, J.-M.; Marchand, D.;
    Marrazzo, A.; Mokrousov, Y.; Mustafa, J. I.; Nohara, Y.; Nomura, Y.; Paulatto, L.; Poncé, S.;
    Ponweiser, T.; Qiao, J.; Thöle, F.; Tsirkin, S. S.; Wierzbowska, M.; Marzari, N.; Vanderbilt, D.;
    Souza, I.; Mostofi, A. A. & Yates, J. R.,
    Wannier90 as a community code: new features and applications,
    [Journal of Physics: Condensed Matter, 2020, 32, 165902](https://doi.org/10.1088/1361-648x/ab51ff)
[^WBERRI]: Tsirkin, S. S., High performance Wannier interpolation of Berry curvature and
    related quantities with WannierBerri code,
    [npj Computational Materials, 2021, 7](https://doi.org/10.1038/s41524-021-00498-5)
